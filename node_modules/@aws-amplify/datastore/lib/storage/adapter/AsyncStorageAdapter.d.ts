import AsyncStorageDatabase from './AsyncStorageDatabase';
import { ModelInstanceMetadata, ModelPredicate, OpType, PaginationInput, PersistentModel, PersistentModelConstructor, QueryOne, RelationType } from '../../types';
import { NAMESPACES } from '../../util';
import { StorageAdapterBase } from './StorageAdapterBase';
export declare class AsyncStorageAdapter extends StorageAdapterBase {
    protected db: AsyncStorageDatabase;
    protected preSetUpChecks(): Promise<void>;
    protected preOpCheck(): Promise<void>;
    /**
     * Open AsyncStorage database
     * Create new DB if one doesn't exist
     *
     * Called by `StorageAdapterBase.setUp()`
     *
     * @returns AsyncStorageDatabase instance
     */
    protected initDb(): Promise<AsyncStorageDatabase>;
    clear(): Promise<void>;
    batchSave<T extends PersistentModel>(modelConstructor: PersistentModelConstructor<any>, items: ModelInstanceMetadata[]): Promise<[T, OpType][]>;
    protected _get<T>(storeName: string, keyArr: string[]): Promise<T>;
    save<T extends PersistentModel>(model: T, condition?: ModelPredicate<T>): Promise<[T, OpType.INSERT | OpType.UPDATE][]>;
    query<T extends PersistentModel>(modelConstructor: PersistentModelConstructor<T>, predicate?: ModelPredicate<T>, pagination?: PaginationInput<T>): Promise<T[]>;
    private getByKey;
    private getAll;
    private filterOnPredicate;
    private inMemoryPagination;
    queryOne<T extends PersistentModel>(modelConstructor: PersistentModelConstructor<T>, firstOrLast?: QueryOne): Promise<T | undefined>;
    protected deleteItem<T extends PersistentModel>(deleteQueue?: {
        storeName: string;
        items: T[] | IDBValidKey[];
    }[]): Promise<void>;
    /**
     * Gets related Has One record for `model`
     *
     * @param model
     * @param srcModel
     * @param namespace
     * @param rel
     * @returns
     */
    protected getHasOneChild<T extends PersistentModel>(model: T, srcModel: string, namespace: NAMESPACES, rel: RelationType): Promise<any>;
    /**
     * Backwards compatability for pre-CPK codegen
     * TODO - deprecate this in v6; will need to re-gen MIPR for older unit
     * tests that hit this path
     */
    protected getHasOneChildLegacy<T extends PersistentModel>(model: T, srcModel: string, namespace: NAMESPACES, rel: RelationType): Promise<T>;
    /**
     *  Gets related Has Many records by given `storeName`, `index`, and `keyValues`
     *
     * @param storeName
     * @param index
     * @param keyValues
     * @returns
     */
    protected getHasManyChildren<T extends PersistentModel>(storeName: string, index: string, keyValues: string[]): Promise<T[]>;
    /**
     * Retrieves concatenated primary key values from a model
     *
     * @param model
     * @returns
     */
    private getIndexKeyValuesPath;
}
declare const _default: AsyncStorageAdapter;
export default _default;
